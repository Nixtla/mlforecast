



# <kbd>module</kbd> `mlforecast.distributed.forecast`




**Global Variables**
---------------
- **DASK_INSTALLED**
- **SPARK_INSTALLED**
- **RAY_INSTALLED**


---



## <kbd>class</kbd> `WindowInfo`
WindowInfo(n_windows, window_size, step_size, i_window, input_size) 





---



## <kbd>class</kbd> `DistributedMLForecast`
Multi backend distributed pipeline 



### <kbd>method</kbd> `__init__`

```python
__init__(
    models,
    freq: Union[int, str],
    lags: Optional[Iterable[int]] = None,
    lag_transforms: Optional[Dict[int, List[Union[Callable, Tuple[Callable, Any]]]]] = None,
    date_features: Optional[Iterable[Union[str, Callable]]] = None,
    num_threads: int = 1,
    target_transforms: Optional[List[Union[BaseTargetTransform, _BaseGroupedArrayTargetTransform]]] = None,
    engine=None,
    num_partitions: Optional[int] = None,
    lag_transforms_namer: Optional[Callable] = None
)
```

Create distributed forecast object 



**Args:**
 
 - <b>`models`</b> (regressor or list of regressors):  Models that will be trained and used to compute the forecasts. 
 - <b>`freq`</b> (str or int, optional):  Pandas offset alias, e.g. 'D', 'W-THU' or integer denoting the frequency of the series. Defaults to None. 
 - <b>`lags`</b> (list of int, optional):  Lags of the target to use as features. Defaults to None. 
 - <b>`lag_transforms`</b> (dict of int to list of functions, optional):  Mapping of target lags to their transformations. Defaults to None. 
 - <b>`date_features`</b> (list of str or callable, optional):  Features computed from the dates. Can be pandas date attributes or functions that will take the dates as input.  Defaults to None. 
 - <b>`num_threads`</b> (int):  Number of threads to use when computing the features. Defaults to 1. 
 - <b>`target_transforms`</b> (list of transformers, optional):  Transformations that will be applied to the target before computing the features and restored after the forecasting step.  Defaults to None. 
 - <b>`engine`</b> (fugue execution engine, optional):  Dask Client, Spark Session, etc to use for the distributed computation.  If None will infer depending on the input type. Defaults to None. 
 - <b>`num_partitions`</b> (number of data partitions to use, optional):  If None, the default partitions provided by the AnyDataFrame used  by the `fit` and `cross_validation` methods will be used. If a Ray  Dataset is provided and `num_partitions` is None, the partitioning  will be done by the `id_col`. Defaults to None. 
 - <b>`lag_transforms_namer`</b> (callable, optional):  Function that takes a transformation (either function or class), a lag and extra arguments and produces a name.  Defaults to None. 




---



### <kbd>method</kbd> `cross_validation`

```python
cross_validation(
    df: ~AnyDataFrame,
    n_windows: int,
    h: int,
    id_col: str = 'unique_id',
    time_col: str = 'ds',
    target_col: str = 'y',
    step_size: Optional[int] = None,
    static_features: Optional[List[str]] = None,
    dropna: bool = True,
    keep_last_n: Optional[int] = None,
    refit: bool = True,
    before_predict_callback: Optional[Callable] = None,
    after_predict_callback: Optional[Callable] = None,
    input_size: Optional[int] = None
) → ~AnyDataFrame
```

Perform time series cross validation. Creates `n_windows` splits where each window has `h` test periods, trains the models, computes the predictions and merges the actuals. 



**Args:**
 
 - <b>`df`</b> (dask, spark or ray DataFrame):  Series data in long format. 
 - <b>`n_windows`</b> (int):  Number of windows to evaluate. 
 - <b>`h`</b> (int):  Number of test periods in each window. 
 - <b>`id_col`</b> (str):  Column that identifies each serie. Defaults to 'unique_id'. 
 - <b>`time_col`</b> (str):  Column that identifies each timestep, its values can be timestamps or integers. Defaults to 'ds'. 
 - <b>`target_col`</b> (str):  Column that contains the target. Defaults to 'y'. 
 - <b>`step_size`</b> (int, optional):  Step size between each cross validation window. If None it will be equal to `h`.  Defaults to None. 
 - <b>`static_features`</b> (list of str, optional):  Names of the features that are static and will be repeated when forecasting.  Defaults to None. 
 - <b>`dropna`</b> (bool):  Drop rows with missing values produced by the transformations. Defaults to True. 
 - <b>`keep_last_n`</b> (int, optional):  Keep only these many records from each serie for the forecasting step. Can save time and memory if your features allow it.  Defaults to None. 
 - <b>`refit`</b> (bool):  Retrain model for each cross validation window.  If False, the models are trained at the beginning and then used to predict each window. Defaults to True. 
 - <b>`before_predict_callback`</b> (callable, optional):  Function to call on the features before computing the predictions.  This function will take the input dataframe that will be passed to the model for predicting and should return a dataframe with the same structure.  The series identifier is on the index. Defaults to None. 
 - <b>`after_predict_callback`</b> (callable, optional):  Function to call on the predictions before updating the targets.  This function will take a pandas Series with the predictions and should return another one with the same structure.  The series identifier is on the index. Defaults to None. 
 - <b>`input_size`</b> (int, optional):  Maximum training samples per serie in each window. If None, will use an expanding window.  Defaults to None. 



**Returns:**
 
 - <b>`(dask, spark or ray DataFrame)`</b>:  Predictions for each window with the series id, timestamp, target value and predictions from each model. 

---



### <kbd>method</kbd> `fit`

```python
fit(
    df: ~AnyDataFrame,
    id_col: str = 'unique_id',
    time_col: str = 'ds',
    target_col: str = 'y',
    static_features: Optional[List[str]] = None,
    dropna: bool = True,
    keep_last_n: Optional[int] = None
) → DistributedMLForecast
```

Apply the feature engineering and train the models. 



**Args:**
 
 - <b>`df`</b> (dask, spark or ray DataFrame):  Series data in long format. 
 - <b>`id_col`</b> (str):  Column that identifies each serie. Defaults to 'unique_id'. 
 - <b>`time_col`</b> (str):  Column that identifies each timestep, its values can be timestamps or integers. Defaults to 'ds'. 
 - <b>`target_col`</b> (str):  Column that contains the target. Defaults to 'y'. 
 - <b>`static_features`</b> (list of str, optional):  Names of the features that are static and will be repeated when forecasting.  Defaults to None. 
 - <b>`dropna`</b> (bool):  Drop rows with missing values produced by the transformations. Defaults to True. 
 - <b>`keep_last_n`</b> (int, optional):  Keep only these many records from each serie for the forecasting step. Can save time and memory if your features allow it.  Defaults to None. 



**Returns:**
 
 - <b>`(DistributedMLForecast)`</b>:  Forecast object with series values and trained models. 

---



### <kbd>method</kbd> `load`

```python
load(path: str, engine) → DistributedMLForecast
```

Load forecast object 



**Args:**
 
 - <b>`path`</b> (str):  Directory with saved artifacts. 
 - <b>`engine`</b> (fugue execution engine):  Dask Client, Spark Session, etc to use for the distributed computation. 

---



### <kbd>method</kbd> `predict`

```python
predict(
    h: int,
    before_predict_callback: Optional[Callable] = None,
    after_predict_callback: Optional[Callable] = None,
    X_df: Optional[DataFrame] = None,
    new_df: Optional[~AnyDataFrame] = None,
    ids: Optional[List[str]] = None
) → ~AnyDataFrame
```

Compute the predictions for the next `horizon` steps. 



**Args:**
 
 - <b>`h`</b> (int):  Forecast horizon. 
 - <b>`before_predict_callback`</b> (callable, optional):  Function to call on the features before computing the predictions.  This function will take the input dataframe that will be passed to the model for predicting and should return a dataframe with the same structure.  The series identifier is on the index. Defaults to None. 
 - <b>`after_predict_callback`</b> (callable, optional):  Function to call on the predictions before updating the targets.  This function will take a pandas Series with the predictions and should return another one with the same structure.  The series identifier is on the index. Defaults to None. 
 - <b>`X_df`</b> (pandas DataFrame, optional):  Dataframe with the future exogenous features. Should have the id column and the time column.  Defaults to None. 
 - <b>`new_df`</b> (dask or spark DataFrame, optional):  Series data of new observations for which forecasts are to be generated.  This dataframe should have the same structure as the one used to fit the model, including any features and time series data.  If `new_df` is not None, the method will generate forecasts for the new observations. Defaults to None. 
 - <b>`ids`</b> (list of str, optional):  List with subset of ids seen during training for which the forecasts should be computed.  Defaults to None. 



**Returns:**
 
 - <b>`(dask, spark or ray DataFrame)`</b>:  Predictions for each serie and timestep, with one column per model. 

---



### <kbd>method</kbd> `preprocess`

```python
preprocess(
    df: ~AnyDataFrame,
    id_col: str = 'unique_id',
    time_col: str = 'ds',
    target_col: str = 'y',
    static_features: Optional[List[str]] = None,
    dropna: bool = True,
    keep_last_n: Optional[int] = None
) → ~AnyDataFrame
```

Add the features to `data`. 



**Args:**
 
 - <b>`df`</b> (dask, spark or ray DataFrame):  Series data in long format. 
 - <b>`id_col`</b> (str):  Column that identifies each serie. Defaults to 'unique_id'. 
 - <b>`time_col`</b> (str):  Column that identifies each timestep, its values can be timestamps or integers. Defaults to 'ds'. 
 - <b>`target_col`</b> (str):  Column that contains the target. Defaults to 'y'. 
 - <b>`static_features`</b> (list of str, optional):  Names of the features that are static and will be repeated when forecasting.  Defaults to None. 
 - <b>`dropna`</b> (bool):  Drop rows with missing values produced by the transformations. Defaults to True. 
 - <b>`keep_last_n`</b> (int, optional):  Keep only these many records from each serie for the forecasting step. Can save time and memory if your features allow it.  Defaults to None. 



**Returns:**
 
 - <b>`(same type as df)`</b>:  `df` with added features. 

---



### <kbd>method</kbd> `save`

```python
save(path: str) → None
```

Save forecast object 



**Args:**
 
 - <b>`path`</b> (str):  Directory where artifacts will be stored. 

---



### <kbd>method</kbd> `to_local`

```python
to_local() → MLForecast
```

Convert this distributed forecast object into a local one 

This pulls all the data from the remote machines, so you have to be sure that it fits in the scheduler/driver. If you're not sure use the save method instead. 



**Returns:**
 
 - <b>`(MLForecast)`</b>:  Local forecast object. 

---



### <kbd>method</kbd> `update`

```python
update(df: DataFrame) → None
```

Update the values of the stored series. 



**Args:**
 
 - <b>`df`</b> (pandas DataFrame):  Dataframe with new observations. 


