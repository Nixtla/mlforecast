---

title: Distributed forecast


keywords: fastai
sidebar: home_sidebar

summary: "Distributed pipeline encapsulation"
description: "Distributed pipeline encapsulation"
nb_path: "nbs/distributed.forecast.ipynb"
---
<!--

#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: nbs/distributed.forecast.ipynb
# command to build the docs after a change: nbdev_build_docs

-->

<div class="container" id="notebook-container">
        
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><strong>This interface is only available on Linux</strong></p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="DistributedForecast" class="doc_header"><code>class</code> <code>DistributedForecast</code><a href="https://github.com/Nixtla/mlforecast/tree/main/mlforecast/distributed/forecast.py#L17" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>DistributedForecast</code>(<strong><code>model</code></strong>, <strong><code>flow_config</code></strong>:<code>Dict</code>[<code>KT</code>, <code>VT</code>], <strong><code>client</code></strong>:<code>Optional</code>[<code>Client</code>]=<em><code>None</code></em>) :: <a href="/mlforecast/forecast.html#Forecast"><code>Forecast</code></a></p>
</blockquote>
<p>Full pipeline encapsulation.</p>
<p>Takes a model (<a href="/mlforecast/distributed.models.lgb.html#LGBMForecast"><code>LGBMForecast</code></a> or <a href="/mlforecast/distributed.models.xgb.html#XGBForecast"><code>XGBForecast</code></a>), a flow configuration and a client.</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>The <a href="/mlforecast/distributed.forecast.html#DistributedForecast"><code>DistributedForecast</code></a> class is a high level abstraction that encapsulates all the steps in the pipeline (preprocessing, fitting the model and computing predictions) and applies them in a distributed way.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Example">Example<a class="anchor-link" href="#Example"> </a></h2><p>This shows an example with simulated data, for a real world example in a remote cluster you can check the <a href="https://www.kaggle.com/lemuz90/m5-mlforecast-distributed">M5 distributed example</a>.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">from</span> <span class="nn">window_ops.expanding</span> <span class="kn">import</span> <span class="n">expanding_mean</span>
<span class="kn">from</span> <span class="nn">window_ops.rolling</span> <span class="kn">import</span> <span class="n">rolling_mean</span><span class="p">,</span> <span class="n">rolling_std</span>

<span class="kn">from</span> <span class="nn">mlforecast.distributed.models.lgb</span> <span class="kn">import</span> <span class="n">LGBMForecast</span>
<span class="kn">from</span> <span class="nn">mlforecast.distributed.models.xgb</span> <span class="kn">import</span> <span class="n">XGBForecast</span>
<span class="kn">from</span> <span class="nn">mlforecast.utils</span> <span class="kn">import</span> <span class="n">generate_daily_series</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>The different things that you need to use <a href="/mlforecast/distributed.forecast.html#DistributedForecast"><code>DistributedForecast</code></a> (as opposed to <a href="/mlforecast/forecast.html#Forecast"><code>Forecast</code></a>) are:</p>
<ol>
<li>You need to set up a <code>dask.distributed.Client</code>. If this client is connected to a remote cluster then the process will run there.</li>
<li>Your data needs to be a <code>dask.dataframe</code>.</li>
<li>You need to use a model that implements distributed training.</li>
</ol>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="Client-setup">Client setup<a class="anchor-link" href="#Client-setup"> </a></h3>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Here we define a client that connects to a <code>dask.distributed.LocalCluster</code>, however it could be any other kind of cluster.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">client</span> <span class="o">=</span> <span class="n">Client</span><span class="p">(</span><span class="n">n_workers</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="Data-setup">Data setup<a class="anchor-link" href="#Data-setup"> </a></h3><p>The data is given as a <code>dask.dataframe</code>, you need to make sure that each time serie is only in one partition and it is recommended that you have as many partitions as you have workers.</p>
<p>The required input format is the same as for <a href="/mlforecast/forecast.html#Forecast"><code>Forecast</code></a>, except that it's a <code>dask.dataframe</code> instead of a <code>pandas.dataframe</code>.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">series</span> <span class="o">=</span> <span class="n">generate_daily_series</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="n">n_static_features</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">equal_ends</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">series</span><span class="o">.</span><span class="n">select_dtypes</span><span class="p">(</span><span class="n">include</span><span class="o">=</span><span class="s1">&#39;category&#39;</span><span class="p">):</span>
    <span class="n">series</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">series</span><span class="p">[</span><span class="n">col</span><span class="p">]</span><span class="o">.</span><span class="n">cat</span><span class="o">.</span><span class="n">codes</span>  <span class="c1"># encode categories for xgboost</span>
<span class="n">partitioned_series</span> <span class="o">=</span> <span class="n">dd</span><span class="o">.</span><span class="n">from_pandas</span><span class="p">(</span><span class="n">series</span><span class="p">,</span> <span class="n">npartitions</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">partitioned_series</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="Model">Model<a class="anchor-link" href="#Model"> </a></h3><p>In order to perform distributed forecasting, we need to use a model that is able to train in a distributed way using <code>dask</code>. The current implementations are in <a href="/mlforecast/distributed.models.lgb.html#LGBMForecast"><code>LGBMForecast</code></a> and <a href="/mlforecast/distributed.models.xgb.html#XGBForecast"><code>XGBForecast</code></a> which are just wrappers around <code>lightgbm.dask.DaskLGBMRegressor</code> and <code>xgboost.dask.DaskXGBRegressor</code> that add a <code>model_</code> property to get the trained model from them and send it to every worker to perform the predictions step.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">model</span> <span class="o">=</span> <span class="n">XGBForecast</span><span class="p">()</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="Flow-configuration">Flow configuration<a class="anchor-link" href="#Flow-configuration"> </a></h3>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>As in the local version (<a href="/mlforecast/forecast.html#Forecast"><code>Forecast</code></a>) a flow configuration is required. This is passed as a dictionary that will be unpacked in the call to our preprocessing function, which is<a href="/mlforecast/core.html#preprocessing_flow"><code>preprocessing_flow</code></a> by default.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span>preprocessing_flow<span class="o">?</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Here where we say that:</p>
<ol>
<li>Our series have daily frequency.</li>
<li>We want to use lag 7 and lag 14 as features.</li>
<li>We want the lag transformations to be:<ul>
<li>expanding mean of the lag 1</li>
<li>rolling mean of the lag 7 over a window of size 7</li>
<li>rolling standard deviation of the lag 7 over a window of size 7</li>
</ul>
</li>
<li>We want to use dayofweek, month and year as date features.</li>
<li>We want to perform the preprocessing and the forecasting steps using 2 threads.</li>
</ol>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">flow_config</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
    <span class="n">freq</span><span class="o">=</span><span class="s1">&#39;D&#39;</span><span class="p">,</span>
    <span class="n">lags</span><span class="o">=</span><span class="p">[</span><span class="mi">7</span><span class="p">],</span>
    <span class="n">lag_transforms</span><span class="o">=</span><span class="p">{</span>
        <span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="n">expanding_mean</span><span class="p">],</span>
        <span class="mi">7</span><span class="p">:</span> <span class="p">[(</span><span class="n">rolling_mean</span><span class="p">,</span> <span class="mi">7</span><span class="p">)]</span>
    <span class="p">},</span>
    <span class="n">date_features</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;dayofweek&#39;</span><span class="p">,</span> <span class="s1">&#39;month&#39;</span><span class="p">],</span>
    <span class="n">num_threads</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
<span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="Training">Training<a class="anchor-link" href="#Training"> </a></h3><p>Once we have our model and flow configuration we instantiate a <a href="/mlforecast/distributed.forecast.html#DistributedForecast"><code>DistributedForecast</code></a> with them.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">fcst</span> <span class="o">=</span> <span class="n">DistributedForecast</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">flow_config</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>From this point we have two options:</p>
<ol>
<li>Preprocess the data and fit our model using all of it.</li>
<li>Preprocess the data and get it back as a dataframe to do some custom splitting or adding additional features. And then training the model.</li>
</ol>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h4 id="1.-Using-all-the-data">1. Using all the data<a class="anchor-link" href="#1.-Using-all-the-data"> </a></h4>
</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="DistributedForecast.fit" class="doc_header"><code>DistributedForecast.fit</code><a href="https://github.com/Nixtla/mlforecast/tree/main/mlforecast/distributed/forecast.py#L46" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>DistributedForecast.fit</code>(<strong><code>data</code></strong>:<code>DataFrame</code>, <strong><code>prep_fn</code></strong>:<code>Callable</code>=<em><code>preprocessing_flow</code></em>, <strong>**<code>fit_kwargs</code></strong>)</p>
</blockquote>
<p>Perform the preprocessing and fit the model.</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Calling <code>.fit</code> on our data computes the features independently for each partition and performs distributed training.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">fcst</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">partitioned_series</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h4 id="2.-Preprocess-and-train">2. Preprocess and train<a class="anchor-link" href="#2.-Preprocess-and-train"> </a></h4>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>If we only want to perform the preprocessing step we call <code>.preprocess</code> on our data.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="DistributedForecast.preprocess" class="doc_header"><code>DistributedForecast.preprocess</code><a href="https://github.com/Nixtla/mlforecast/tree/main/mlforecast/distributed/forecast.py#L33" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>DistributedForecast.preprocess</code>(<strong><code>data</code></strong>:<code>DataFrame</code>, <strong><code>prep_fn</code></strong>:<code>Callable</code>=<em><code>preprocessing_flow</code></em>)</p>
</blockquote>
<p>Applies <code>prep_fn(partition, **self.flow_config)</code> on each partition of <code>data</code>.</p>
<p>Saves the resulting <a href="/mlforecast/core.html#TimeSeries"><code>TimeSeries</code></a> objects as well as the divisions in <code>data</code> for the forecasting step.
Returns a dask dataframe with the computed features.</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">features_ddf</span> <span class="o">=</span> <span class="n">fcst</span><span class="o">.</span><span class="n">preprocess</span><span class="p">(</span><span class="n">partitioned_series</span><span class="p">)</span>
<span class="n">features_ddf</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>This is useful if we want to inspect the data the model will be trained, adding additional features or performing some custom train-valid split. Here we perform a 80-20 split.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">rng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">mask_as_series</span><span class="p">(</span><span class="n">df</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">rng</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&lt;</span> <span class="mf">0.8</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>

<span class="n">train_mask</span> <span class="o">=</span> <span class="n">features_ddf</span><span class="o">.</span><span class="n">map_partitions</span><span class="p">(</span><span class="n">mask_as_series</span><span class="p">)</span>
<span class="n">train</span><span class="p">,</span> <span class="n">valid</span> <span class="o">=</span> <span class="n">features_ddf</span><span class="p">[</span><span class="n">train_mask</span><span class="p">],</span> <span class="n">features_ddf</span><span class="p">[</span><span class="o">~</span><span class="n">train_mask</span><span class="p">]</span>
<span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span> <span class="o">=</span> <span class="n">train</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;ds&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">]),</span> <span class="n">train</span><span class="o">.</span><span class="n">y</span>
<span class="n">X_valid</span><span class="p">,</span> <span class="n">y_valid</span> <span class="o">=</span> <span class="n">valid</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;ds&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">]),</span> <span class="n">valid</span><span class="o">.</span><span class="n">y</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>If we do this we must "manually" train our model calling <a href="/mlforecast/distributed.forecast.html#DistributedForecast.model.fit"><code>DistributedForecast.model.fit</code></a>.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">fcst</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> 
               <span class="n">eval_set</span><span class="o">=</span><span class="p">[(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">),</span> <span class="p">(</span><span class="n">X_valid</span><span class="p">,</span> <span class="n">y_valid</span><span class="p">)],</span>
               <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">for</span> <span class="n">lab</span> <span class="ow">in</span> <span class="n">fcst</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">evals_result_</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">fcst</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">evals_result_</span><span class="p">[</span><span class="n">lab</span><span class="p">][</span><span class="s1">&#39;rmse&#39;</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="n">lab</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">();</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="Forecasting">Forecasting<a class="anchor-link" href="#Forecasting"> </a></h3><p>Once we have our fitted model we can compute the predictions for the next 7 timesteps.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="DistributedForecast.predict" class="doc_header"><code>DistributedForecast.predict</code><a href="https://github.com/Nixtla/mlforecast/tree/main/mlforecast/distributed/forecast.py#L55" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>DistributedForecast.predict</code>(<strong><code>horizon</code></strong>:<code>int</code>, <strong><code>predict_fn</code></strong>:<code>Callable</code>=<em><code>predictions_flow</code></em>, <strong>**<code>predict_fn_kwargs</code></strong>)</p>
</blockquote>
<p>Compute the predictions for the next <code>horizon</code> steps using <code>predict_fn</code>.</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">preds</span> <span class="o">=</span> <span class="n">fcst</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="n">preds</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="Backtesting">Backtesting<a class="anchor-link" href="#Backtesting"> </a></h3><p>If we would like to know how good our forecast will be for a specific model and set of features then we can perform backtesting. What backtesting does is take our data and split it in two parts, where the first part is used for training and the second one for validation. Since the data is time dependant we usually take the last <em>x</em> observations from our data as the validation set.</p>
<p>This process is implemented in <a href="/mlforecast/forecast.html#Forecast.backtest"><code>Forecast.backtest</code></a> (and inherited by <a href="/mlforecast/distributed.forecast.html#DistributedForecast"><code>DistributedForecast</code></a>), which takes our data and performs the process described above for <code>n_windows</code> times where each window is of size <code>window_size</code>. For example, if we have 100 samples and we want to perform 2 backtests each of size 14, the splits will be as follows:</p>
<ol>
<li>Train: 1 to 72. Validation: 73 to 86.</li>
<li>Train: 1 to 86. Validation: 87 to 100.</li>
</ol>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="Forecast.backtest" class="doc_header"><code>Forecast.backtest</code><a href="https://github.com/Nixtla/mlforecast/tree/main/mlforecast/forecast.py#L52" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>Forecast.backtest</code>(<strong><code>data</code></strong>, <strong><code>n_windows</code></strong>:<code>int</code>, <strong><code>window_size</code></strong>:<code>int</code>, <strong><code>predict_fn</code></strong>:<code>Callable</code>=<em><code>predictions_flow</code></em>, <strong>**<code>predict_fn_kwargs</code></strong>)</p>
</blockquote>
<p>Creates <code>n_windows</code> splits of <code>window_size</code> from <code>data</code>, trains the model
on the training set, predicts the window and merges the actuals and the predictions
in a dataframe.</p>
<p>Returns a generator to the dataframes containing the datestamps, actual values
and predictions.</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">n_windows</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">window_size</span> <span class="o">=</span> <span class="mi">14</span>

<span class="n">fcst</span> <span class="o">=</span> <span class="n">DistributedForecast</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">flow_config</span><span class="p">)</span>
<span class="n">backtest_results</span> <span class="o">=</span> <span class="n">fcst</span><span class="o">.</span><span class="n">backtest</span><span class="p">(</span><span class="n">partitioned_series</span><span class="p">,</span> <span class="n">n_windows</span><span class="p">,</span> <span class="n">window_size</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>This returns a generator that yields the results of each window one at a time.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">window1_result</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">backtest_results</span><span class="p">)</span>
<span class="n">window1_result</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">window2_result</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">backtest_results</span><span class="p">)</span>
<span class="n">results</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">window1_result</span><span class="o">.</span><span class="n">compute</span><span class="p">(),</span> <span class="n">window2_result</span><span class="o">.</span><span class="n">compute</span><span class="p">()])</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>We can aggregate these by date to get a rough estimate of how our model is doing.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">agg_results</span> <span class="o">=</span> <span class="n">results</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s1">&#39;ds&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
<span class="n">agg_results</span><span class="o">.</span><span class="n">plot</span><span class="p">();</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>We can include some more context by using the values in the training set.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">history</span> <span class="o">=</span> <span class="n">series</span><span class="p">[</span><span class="n">series</span><span class="o">.</span><span class="n">ds</span> <span class="o">&lt;</span> <span class="n">agg_results</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">min</span><span class="p">()]</span>
<span class="n">agg_history</span> <span class="o">=</span> <span class="n">history</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s1">&#39;ds&#39;</span><span class="p">)[[</span><span class="s1">&#39;y&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="o">.</span><span class="n">tail</span><span class="p">(</span><span class="mi">50</span><span class="p">)</span>
<span class="n">agg_history</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">agg_results</span><span class="p">)</span><span class="o">.</span><span class="n">plot</span><span class="p">();</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Note that since the backtest results are returned as a generator we can also compute a single statistic on them and not keep the whole results in memory.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">def</span> <span class="nf">mse_from_dask_dataframe</span><span class="p">(</span><span class="n">ddf</span><span class="p">):</span>
    <span class="n">ddf</span><span class="p">[</span><span class="s1">&#39;sq_err&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">ddf</span><span class="p">[</span><span class="s1">&#39;y&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">ddf</span><span class="p">[</span><span class="s1">&#39;y_pred&#39;</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span>
    <span class="n">mse</span> <span class="o">=</span> <span class="n">ddf</span><span class="p">[</span><span class="s1">&#39;sq_err&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">mse</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">fcst</span> <span class="o">=</span> <span class="n">DistributedForecast</span><span class="p">(</span><span class="n">XGBForecast</span><span class="p">(),</span> <span class="n">flow_config</span><span class="p">)</span>
<span class="n">backtest_results</span> <span class="o">=</span> <span class="n">fcst</span><span class="o">.</span><span class="n">backtest</span><span class="p">(</span><span class="n">partitioned_series</span><span class="p">,</span> <span class="n">n_windows</span><span class="p">,</span> <span class="n">window_size</span><span class="p">)</span>

<span class="n">losses</span> <span class="o">=</span> <span class="p">[</span><span class="n">mse_from_dask_dataframe</span><span class="p">(</span><span class="n">res</span><span class="p">)</span> <span class="k">for</span> <span class="n">res</span> <span class="ow">in</span> <span class="n">backtest_results</span><span class="p">]</span>
<span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">losses</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>We can try <a href="/mlforecast/distributed.models.lgb.html#LGBMForecast"><code>LGBMForecast</code></a> as well</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">fcst</span> <span class="o">=</span> <span class="n">DistributedForecast</span><span class="p">(</span><span class="n">LGBMForecast</span><span class="p">(),</span> <span class="n">flow_config</span><span class="p">)</span>
<span class="n">backtest_results</span> <span class="o">=</span> <span class="n">fcst</span><span class="o">.</span><span class="n">backtest</span><span class="p">(</span><span class="n">partitioned_series</span><span class="p">,</span> <span class="n">n_windows</span><span class="p">,</span> <span class="n">window_size</span><span class="p">)</span>

<span class="n">losses</span> <span class="o">=</span> <span class="p">[</span><span class="n">mse_from_dask_dataframe</span><span class="p">(</span><span class="n">res</span><span class="p">)</span> <span class="k">for</span> <span class="n">res</span> <span class="ow">in</span> <span class="n">backtest_results</span><span class="p">]</span>
<span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">losses</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

</div>
 

