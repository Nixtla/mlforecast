



# <kbd>module</kbd> `mlforecast.target_transforms`






---



## <kbd>class</kbd> `BaseTargetTransform`
Base class used for target transformations. 




---



### <kbd>method</kbd> `fit_transform`

```python
fit_transform(df: Union[DataFrame, DataFrame]) → Union[DataFrame, DataFrame]
```





---



### <kbd>method</kbd> `inverse_transform`

```python
inverse_transform(df: Union[DataFrame, DataFrame]) → Union[DataFrame, DataFrame]
```





---



### <kbd>method</kbd> `set_column_names`

```python
set_column_names(id_col: str, time_col: str, target_col: str)
```





---



### <kbd>method</kbd> `stack`

```python
stack(
    transforms: Sequence[ForwardRef('BaseTargetTransform')]
) → BaseTargetTransform
```





---



### <kbd>method</kbd> `update`

```python
update(df: Union[DataFrame, DataFrame]) → Union[DataFrame, DataFrame]
```






---



## <kbd>class</kbd> `Differences`
Subtracts previous values of the serie. Can be used to remove trend or seasonalities. 



### <kbd>method</kbd> `__init__`

```python
__init__(differences: Iterable[int])
```








---



### <kbd>method</kbd> `fit_transform`

```python
fit_transform(ga: GroupedArray) → GroupedArray
```





---



### <kbd>method</kbd> `inverse_transform`

```python
inverse_transform(ga: GroupedArray) → GroupedArray
```





---



### <kbd>method</kbd> `inverse_transform_fitted`

```python
inverse_transform_fitted(ga: GroupedArray) → GroupedArray
```





---



### <kbd>method</kbd> `set_num_threads`

```python
set_num_threads(num_threads: int) → None
```





---



### <kbd>method</kbd> `stack`

```python
stack(scalers: Sequence[ForwardRef('Differences')]) → Differences
```





---



### <kbd>method</kbd> `take`

```python
take(idxs: ndarray) → Differences
```





---



### <kbd>method</kbd> `update`

```python
update(ga: GroupedArray) → GroupedArray
```






---



## <kbd>class</kbd> `AutoDifferences`
Find and apply the optimal number of differences to each serie. 



**Args:**
 
 - <b>`max_diffs`</b> (int):  Maximum number of differences to apply. 



### <kbd>method</kbd> `__init__`

```python
__init__(max_diffs: int)
```








---



### <kbd>method</kbd> `fit_transform`

```python
fit_transform(ga: GroupedArray) → GroupedArray
```





---



### <kbd>method</kbd> `inverse_transform`

```python
inverse_transform(ga: GroupedArray) → GroupedArray
```





---



### <kbd>method</kbd> `inverse_transform_fitted`

```python
inverse_transform_fitted(ga: GroupedArray) → GroupedArray
```





---



### <kbd>method</kbd> `set_num_threads`

```python
set_num_threads(num_threads: int) → None
```





---



### <kbd>method</kbd> `stack`

```python
stack(
    scalers: Sequence[ForwardRef('_BaseGroupedArrayTargetTransform')]
) → _BaseGroupedArrayTargetTransform
```





---



### <kbd>method</kbd> `take`

```python
take(idxs: ndarray) → AutoDifferences
```





---



### <kbd>method</kbd> `update`

```python
update(ga: GroupedArray) → GroupedArray
```






---



## <kbd>class</kbd> `AutoSeasonalDifferences`
Find and apply the optimal number of seasonal differences to each group. 



**Args:**
 
 - <b>`season_length`</b> (int):  Length of the seasonal period. 
 - <b>`max_diffs`</b> (int):  Maximum number of differences to apply. 
 - <b>`n_seasons`</b> (int, optional):  Number of seasons to use to determine the number of differences. Defaults to 10.  If `None` will use all samples, otherwise `season_length` * `n_seasons samples` will be used for the test.  Smaller values will be faster but could be less accurate. 



### <kbd>method</kbd> `__init__`

```python
__init__(season_length: int, max_diffs: int, n_seasons: Optional[int] = 10)
```








---



### <kbd>method</kbd> `fit_transform`

```python
fit_transform(ga: GroupedArray) → GroupedArray
```





---



### <kbd>method</kbd> `inverse_transform`

```python
inverse_transform(ga: GroupedArray) → GroupedArray
```





---



### <kbd>method</kbd> `inverse_transform_fitted`

```python
inverse_transform_fitted(ga: GroupedArray) → GroupedArray
```





---



### <kbd>method</kbd> `set_num_threads`

```python
set_num_threads(num_threads: int) → None
```





---



### <kbd>method</kbd> `stack`

```python
stack(
    scalers: Sequence[ForwardRef('_BaseGroupedArrayTargetTransform')]
) → _BaseGroupedArrayTargetTransform
```





---



### <kbd>method</kbd> `take`

```python
take(idxs: ndarray) → AutoDifferences
```





---



### <kbd>method</kbd> `update`

```python
update(ga: GroupedArray) → GroupedArray
```






---



## <kbd>class</kbd> `AutoSeasonalityAndDifferences`
Find the length of the seasonal period and apply the optimal number of differences to each group. 



**Args:**
 
 - <b>`max_season_length`</b> (int):  Maximum length of the seasonal period. 
 - <b>`max_diffs`</b> (int):  Maximum number of differences to apply. 
 - <b>`n_seasons`</b> (int, optional):  Number of seasons to use to determine the number of differences. Defaults to 10.  If `None` will use all samples, otherwise `max_season_length` * `n_seasons samples` will be used for the test.  Smaller values will be faster but could be less accurate. 



### <kbd>method</kbd> `__init__`

```python
__init__(max_season_length: int, max_diffs: int, n_seasons: Optional[int] = 10)
```








---



### <kbd>method</kbd> `fit_transform`

```python
fit_transform(ga: GroupedArray) → GroupedArray
```





---



### <kbd>method</kbd> `inverse_transform`

```python
inverse_transform(ga: GroupedArray) → GroupedArray
```





---



### <kbd>method</kbd> `inverse_transform_fitted`

```python
inverse_transform_fitted(ga: GroupedArray) → GroupedArray
```





---



### <kbd>method</kbd> `set_num_threads`

```python
set_num_threads(num_threads: int) → None
```





---



### <kbd>method</kbd> `stack`

```python
stack(
    scalers: Sequence[ForwardRef('_BaseGroupedArrayTargetTransform')]
) → _BaseGroupedArrayTargetTransform
```





---



### <kbd>method</kbd> `take`

```python
take(idxs: ndarray) → AutoDifferences
```





---



### <kbd>method</kbd> `update`

```python
update(ga: GroupedArray) → GroupedArray
```






---



## <kbd>class</kbd> `LocalStandardScaler`
Standardizes each serie by subtracting its mean and dividing by its standard deviation. 




---



### <kbd>method</kbd> `fit_transform`

```python
fit_transform(ga: GroupedArray) → GroupedArray
```





---



### <kbd>method</kbd> `inverse_transform`

```python
inverse_transform(ga: GroupedArray) → GroupedArray
```





---



### <kbd>method</kbd> `inverse_transform_fitted`

```python
inverse_transform_fitted(ga: GroupedArray) → GroupedArray
```





---



### <kbd>method</kbd> `set_num_threads`

```python
set_num_threads(num_threads: int) → None
```





---



### <kbd>method</kbd> `stack`

```python
stack(
    scalers: Sequence[ForwardRef('_BaseGroupedArrayTargetTransform')]
) → _BaseGroupedArrayTargetTransform
```





---



### <kbd>method</kbd> `take`

```python
take(idxs: ndarray) → _BaseLocalScaler
```





---



### <kbd>method</kbd> `update`

```python
update(ga: GroupedArray) → GroupedArray
```






---



## <kbd>class</kbd> `LocalMinMaxScaler`
Scales each serie to be in the [0, 1] interval. 




---



### <kbd>method</kbd> `fit_transform`

```python
fit_transform(ga: GroupedArray) → GroupedArray
```





---



### <kbd>method</kbd> `inverse_transform`

```python
inverse_transform(ga: GroupedArray) → GroupedArray
```





---



### <kbd>method</kbd> `inverse_transform_fitted`

```python
inverse_transform_fitted(ga: GroupedArray) → GroupedArray
```





---



### <kbd>method</kbd> `set_num_threads`

```python
set_num_threads(num_threads: int) → None
```





---



### <kbd>method</kbd> `stack`

```python
stack(
    scalers: Sequence[ForwardRef('_BaseGroupedArrayTargetTransform')]
) → _BaseGroupedArrayTargetTransform
```





---



### <kbd>method</kbd> `take`

```python
take(idxs: ndarray) → _BaseLocalScaler
```





---



### <kbd>method</kbd> `update`

```python
update(ga: GroupedArray) → GroupedArray
```






---



## <kbd>class</kbd> `LocalRobustScaler`
Scaler robust to outliers. 



**Args:**
 
 - <b>`scale`</b> (str):  Statistic to use for scaling. Can be either 'iqr' (Inter Quartile Range) or 'mad' (Median Asbolute Deviation).  Defaults to 'iqr'. 



### <kbd>method</kbd> `__init__`

```python
__init__(scale: str)
```








---



### <kbd>method</kbd> `fit_transform`

```python
fit_transform(ga: GroupedArray) → GroupedArray
```





---



### <kbd>method</kbd> `inverse_transform`

```python
inverse_transform(ga: GroupedArray) → GroupedArray
```





---



### <kbd>method</kbd> `inverse_transform_fitted`

```python
inverse_transform_fitted(ga: GroupedArray) → GroupedArray
```





---



### <kbd>method</kbd> `set_num_threads`

```python
set_num_threads(num_threads: int) → None
```





---



### <kbd>method</kbd> `stack`

```python
stack(
    scalers: Sequence[ForwardRef('_BaseGroupedArrayTargetTransform')]
) → _BaseGroupedArrayTargetTransform
```





---



### <kbd>method</kbd> `take`

```python
take(idxs: ndarray) → _BaseLocalScaler
```





---



### <kbd>method</kbd> `update`

```python
update(ga: GroupedArray) → GroupedArray
```






---



## <kbd>class</kbd> `LocalBoxCox`
Finds the optimum lambda for each serie and applies the Box-Cox transformation 



### <kbd>method</kbd> `__init__`

```python
__init__()
```








---



### <kbd>method</kbd> `fit_transform`

```python
fit_transform(ga: GroupedArray) → GroupedArray
```





---



### <kbd>method</kbd> `inverse_transform`

```python
inverse_transform(ga: GroupedArray) → GroupedArray
```





---



### <kbd>method</kbd> `inverse_transform_fitted`

```python
inverse_transform_fitted(ga: GroupedArray) → GroupedArray
```





---



### <kbd>method</kbd> `set_num_threads`

```python
set_num_threads(num_threads: int) → None
```





---



### <kbd>method</kbd> `stack`

```python
stack(
    scalers: Sequence[ForwardRef('_BaseGroupedArrayTargetTransform')]
) → _BaseGroupedArrayTargetTransform
```





---



### <kbd>method</kbd> `take`

```python
take(idxs: ndarray) → _BaseLocalScaler
```





---



### <kbd>method</kbd> `update`

```python
update(ga: GroupedArray) → GroupedArray
```






---



## <kbd>class</kbd> `GlobalSklearnTransformer`
Applies the same scikit-learn transformer to all series. 



### <kbd>method</kbd> `__init__`

```python
__init__(transformer: TransformerMixin)
```








---



### <kbd>method</kbd> `fit_transform`

```python
fit_transform(df: Union[DataFrame, DataFrame]) → Union[DataFrame, DataFrame]
```





---



### <kbd>method</kbd> `inverse_transform`

```python
inverse_transform(df: Union[DataFrame, DataFrame]) → Union[DataFrame, DataFrame]
```





---



### <kbd>method</kbd> `set_column_names`

```python
set_column_names(id_col: str, time_col: str, target_col: str)
```





---



### <kbd>method</kbd> `stack`

```python
stack(
    transforms: Sequence[ForwardRef('GlobalSklearnTransformer')]
) → GlobalSklearnTransformer
```





---



### <kbd>method</kbd> `update`

```python
update(df: Union[DataFrame, DataFrame]) → Union[DataFrame, DataFrame]
```






