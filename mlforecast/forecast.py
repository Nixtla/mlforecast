# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/forecast.ipynb.

# %% ../nbs/forecast.ipynb 3
from __future__ import annotations

import reprlib
from typing import Callable, List, Optional, Union

import pandas as pd
from sklearn.base import RegressorMixin

from .core import TimeSeries
from .utils import backtest_splits

# %% auto 0
__all__ = ['Forecast']

# %% ../nbs/forecast.ipynb 7
class Forecast:
    """Full pipeline encapsulation."""

    def __init__(
        self,
        models: Union[
            RegressorMixin, List[RegressorMixin]
        ],  # model or list of models that follow the scikit-learn API
        freq: str,  # pandas offset alias, e.g. D, W, M
        lags: List[int] = [],  # list of lags to use as features
        lag_transforms: Dict[
            int, List[Tuple]
        ] = {},  # list of transformations to apply to each lag
        date_features: List[
            str
        ] = [],  # list of names of pandas date attributes to use as features, e.g. dayofweek
        num_threads: int = 1,  # number of threads to use when computing lag features
    ):
        if not isinstance(models, list):
            models = [models]
        self.models = models
        self.ts = TimeSeries(freq, lags, lag_transforms, date_features, num_threads)

    def __repr__(self):
        return (
            f"Forecast(models={reprlib.repr(self.models)}, "
            f"freq={self.ts.freq}, "
            f"lag_features={reprlib.repr(self.ts.transforms)}, "
            f"date_features={reprlib.repr(self.ts.date_features)}, "
            f"num_threads={self.ts.num_threads})"
        )

    @property
    def freq(self):
        return self.ts.freq

    def preprocess(
        self,
        data: pd.DataFrame,
        static_features: Optional[List[str]] = None,
        dropna: bool = True,
        keep_last_n: Optional[int] = None,
    ) -> pd.DataFrame:
        return self.ts.fit_transform(data, static_features, dropna, keep_last_n)

    def fit(
        self,
        data: pd.DataFrame,
        static_features: Optional[List[str]] = None,
        dropna: bool = True,
        keep_last_n: Optional[int] = None,
        **fit_kwargs,
    ) -> "Forecast":
        """Preprocesses `data` and fits `model` to it."""
        series_df = self.preprocess(data, static_features, dropna, keep_last_n)
        X, y = series_df.drop(columns=["ds", "y"]), series_df.y.values
        del series_df
        for model in self.models:
            model.fit(X, y, **fit_kwargs)
        return self

    def predict(
        self,
        horizon: int,
        dynamic_dfs: Optional[List[pd.DataFrame]] = None,
        predict_fn: Optional[Callable] = None,
        **predict_fn_kwargs,
    ) -> pd.DataFrame:
        """Compute the predictions for the next `horizon` steps.

        `predict_fn(model, new_x, features_order, **predict_fn_kwargs)` is called in every timestep, where:
        `model` is the trained model.
        `new_x` is a dataframe with the same format as the input plus the computed features.
        `features_order` is the list of column names that were used in the training step.
        """
        return self.ts.predict(
            self.models, horizon, dynamic_dfs, predict_fn, **predict_fn_kwargs
        )

    def cross_validation(
        self,
        data,
        n_windows: int,
        window_size: int,
        static_features: Optional[List[str]] = None,
        dropna: bool = True,
        keep_last_n: Optional[int] = None,
        dynamic_dfs: Optional[List[pd.DataFrame]] = None,
        predict_fn: Optional[Callable] = None,
        **predict_fn_kwargs,
    ):
        """Creates `n_windows` splits of `window_size` from `data`, trains the model
        on the training set, predicts the window and merges the actuals and the predictions
        in a dataframe.

        Returns a dataframe containing the datestamps, actual values, train ends and predictions."""
        results = []
        for train_end, train, valid in backtest_splits(
            data, n_windows, window_size, self.freq
        ):
            self.fit(train, static_features, dropna, keep_last_n)
            y_pred = self.predict(
                window_size, dynamic_dfs, predict_fn, **predict_fn_kwargs
            )
            result = valid[["ds", "y"]].copy()
            result["cutoff"] = train_end
            result = result.merge(y_pred, on=["unique_id", "ds"], how="left")
            results.append(result)

        from mlforecast.compat import dd_concat

        concat_fn = pd.concat if isinstance(data, pd.DataFrame) else dd_concat
        return concat_fn(results)
