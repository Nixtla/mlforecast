# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/distributed.core.ipynb (unless otherwise specified).

__all__ = ['DistributedTimeSeries']

# Cell
import operator
from typing import Dict, List, Optional, Tuple

import dask.dataframe as dd
from dask.distributed import Client, default_client, futures_of, wait

from ..core import TimeSeries


# Internal Cell
def _fit_transform(init_kwargs, data):
    ts = TimeSeries(**init_kwargs)
    df = ts.fit_transform(data)
    return ts, df


def _predict(ts, model, horizon, **kwargs):
    return ts.predict(model, horizon, **kwargs)


# Cell
class DistributedTimeSeries:
    def __init__(
        self,
        freq: str = 'D',
        lags: List[int] = [],
        lag_transforms: Dict[int, List[Tuple]] = {},
        date_features: List[str] = [],
        num_threads: Optional[int] = None,
        client: Optional[Client] = None,
    ):
        self._init_kwargs = dict(
            freq=freq,
            lags=lags,
            lag_transforms=lag_transforms,
            date_features=date_features,
            num_threads=num_threads,
        )
        self.client = client or default_client()
        self._ts_for_repr = TimeSeries(
            freq, lags, lag_transforms, date_features, num_threads
        )

    def fit_transform(self, data: dd.DataFrame) -> dd.DataFrame:
        self.data_divisions = data.divisions
        data = self.client.persist(data)
        wait(data)
        partition_futures = futures_of(data)
        self.ts = []
        df_futures = []
        for part_future in partition_futures:
            future = self.client.submit(
                _fit_transform, self._init_kwargs, part_future, pure=False
            )
            ts_future = self.client.submit(operator.itemgetter(0), future)
            df_future = self.client.submit(operator.itemgetter(1), future)
            self.ts.append(ts_future)
            df_futures.append(df_future)
        meta = self.client.submit(lambda x: x.head(0), df_futures[0]).result()
        return dd.from_delayed(df_futures, meta=meta)

    def predict(self, model, horizon: int, **kwargs) -> dd.DataFrame:
        model_future = self.client.scatter(model, broadcast=True)
        predictions_futures = [
            self.client.submit(_predict, ts_future, model_future, horizon, **kwargs)
            for ts_future in self.ts
        ]
        meta = self.client.submit(lambda x: x.head(), predictions_futures[0]).result()
        return dd.from_delayed(
            predictions_futures, meta=meta, divisions=self.data_divisions
        )

    def __repr__(self):
        ts_repr = self._ts_for_repr.__repr__()
        return f'Distributed{ts_repr}'
