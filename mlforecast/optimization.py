# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/optimization.ipynb.

# %% auto 0
__all__ = ['mlforecast_objective']

# %% ../nbs/optimization.ipynb 2
import copy
from typing import Callable, List, Optional

import numpy as np
import optuna
import utilsforecast.processing as ufp
from sklearn.base import BaseEstimator, clone
from utilsforecast.compat import DataFrame
from utilsforecast.losses import smape

from . import MLForecast
from .core import Freq

# %% ../nbs/optimization.ipynb 3
def mlforecast_objective(
    df: DataFrame,
    config_fn: Callable,
    eval_fn: Callable,
    model: BaseEstimator,
    freq: Freq,
    n_windows: int,
    h: int,
    id_col: str = "unique_id",
    time_col: str = "ds",
    target_col: str = "y",
) -> Callable:
    def objective(trial: optuna.Trial) -> float:
        config = config_fn(trial)
        trial.set_user_attr("config", copy.deepcopy(config))
        splits = ufp.backtest_splits(
            df,
            n_windows=n_windows,
            h=h,
            id_col=id_col,
            time_col=time_col,
            freq=freq,
        )
        model_copy = clone(model)
        model_copy.set_params(**config["model_params"])
        metrics = []
        for i, (_, train, valid) in enumerate(splits):
            mlf = MLForecast(
                models={"model": model_copy},
                freq=freq,
                **config["mlf_init_params"],
            )
            mlf.fit(
                train,
                id_col=id_col,
                time_col=time_col,
                target_col=target_col,
                **config["mlf_fit_params"],
            )
            static = [c for c in mlf.ts.static_features_.columns if c != id_col]
            dynamic = [
                c
                for c in valid.columns
                if c not in static + [id_col, time_col, target_col]
            ]
            if dynamic:
                X_df: Optional[DataFrame] = ufp.drop_columns(
                    valid, static + [target_col]
                )
            else:
                X_df = None
            preds = mlf.predict(h=h, X_df=X_df)
            full = valid.merge(preds, on=[id_col, time_col], how="left")
            if full.shape[0] < valid.shape[0]:
                raise ValueError(
                    "Cross validation result produced less results than expected. "
                    "Please verify that the passed frequency (freq) matches your series' "
                    "and that there aren't any missing periods."
                )
            metric = eval_fn(full)
            metrics.append(metric)
            trial.report(metric, step=i)
            if trial.should_prune():
                raise optuna.TrialPruned()
        return np.mean(metrics)

    return objective
